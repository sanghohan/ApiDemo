input {
  tcp {
    port => 8080
    codec => json_lines {
      target => "json"
    }
  }
}


filter {
  aggregate {
    task_id => "%{traceId}"
    code => "
      map['logs'] ||= [];
      map['logs'] << event.to_hash;
      if event.get('error_traceId')
        map['error_occurred'] = true;
      end;
      event.cancel();
    "
    push_map_as_event_on_timeout => true
    timeout => 10
    timeout_code => "

    if map['error_occurred']
        # logs.message는 message 필드를 배열로 모은다
        messages = map['logs'].map { |log| log['message'] }
        map['logs'] = map['logs'].sort_by { |log| log['@timestamp'] }

        #event.set('logs', map['logs']);
        event.set('logs.message', messages)  # logs.message 배열 필드 생성
        # 나머지 필드는 첫 번째 항목의 값만 가져온다
        event.set('traceId', map['logs'].first['traceId'])
        #event.set('@timestamp', map['logs'].first['@timestamp'])
        #event.set('level', map['logs'].first['level'])  # 예시: level도 첫 번째 로그로 설정
        event.set('thread_name', map['logs'].first['thread_name'])
        event.set('logs', map['logs']);
      else
        event.cancel();
      end
    "
  }
}

output {
  if [error_occurred] {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "error-logs-%{+YYYY.MM.dd}"
    }
  }
  stdout {
    codec => rubydebug
  }

}